# Login Process 진행
# REST API 호출
현재 상황에서 로그인을 성공한다고 하더라도 jwt를 세션 스토리지에 저장했을 뿐이고, 
아직 getCars()의 결과값을 가져오지는 못합니다.

이 이유는 기본적으로 Login 컴포넌트에서 얻은 토큰을 가지러 frontend상에서 Carlist를 불러오지 못하고 있는 상황이기 때문입니다.

carapi.ts에 getCars() 호출을 할 때 얻어온 jwt를 사용해야 하기 때문입니다.
근데 jwtToken값이 생각해보면 .then()에 걸려있기 때문에 일종의 지역변수라고 볼 수 있겠습니다.
그렇다면 Login 컴포넌트를 벗어나서는 사용할 수 없다는 의미가 될겁니다.
그러면 얘를 어떻게 끌고 와서 getCars() 함수에 jwt값을 넣어서 같이 GET요청을 보낼 수 있을지 그냥 고민만 해보겠습니다.

우리가 sessionStorage에 굳이 setItem을 한 이유에 대해서 생각해봐야합니다.-> carapi.ts에서 쓰려고.

그래서 api들에 token 집어넣는 거 하고나서는 중복 코드를 리팩토링할 예정입니다.
지금 보면 결과적으로 token을 함수들에서 전부 다 꺼내쓰고 있는 중인데다가 Authorization : token 뭐 이런 부분이 반복적으로 쓰이는 것을 확인할 수 있습니다.

```ts
import axios from "axios";
import { CarResponse, Car, CarEntity } from "../types";

export const getCars = async (): Promise<CarResponse[]> => {
    const token = sessionStorage.getItem('jwt');

    // 세션 스토리지 상에 'Bearer'가 포함되어있습니다. 근데 저희가 Postman에서 요청날릴 때 'Bearer'부분을 빼놓고 붙여넣기 했었던 것을 떠올려서 
    // 프론트엔드 상에서 'Bearer'를 제거하고, 그걸 기준으로 요청을 날렸습니다.
    const rawToken = token?.replace('Bearer', '');
    const response = await axios.get(`${import.meta.env.VITE_API_URL}/api/cars`, {
        headers: { 'Authorization' : `${rawToken}`}
    }); 
    
    return response.data._embedded.cars;
}

export const deleteCar = async (link: string) : Promise<CarResponse> => {
    //chaining method를 활용한 코드도 하나는 남겨놓겠습니다.
    const token = sessionStorage.getItem('jwt')?.replace('Bearer', '');
    const response = await axios.delete(link, {
        headers: { 'Authorization' : `${token}`}
    });
    return response.data
}

export const addCar = async (car: Car) : Promise<CarResponse> => {    // 보낼때는 Car 자료형, 돌아올때는 CarResponse 자료형
    const token = sessionStorage.getItem('jwt');
    const rawToken = token?.replace('Bearer', '');
    const response = await axios.post(`${import.meta.env.VITE_API_URL}/api/cars`, car, {
        headers: {
            'Content-Type' : 'application/json',
            'Authorization':rawToken
        },
    });

    return response.data;
}


export const updateCar =async(carEntity: CarEntity): Promise<CarResponse> => {
    const token = sessionStorage.getItem('jwt');
    const rawToken = token?.replace('Bearer', '');
    const response = await axios.put(carEntity.url, carEntity.car, {
        headers: {
            'Content-Type': 'application/json',
            'Authorization': rawToken
        },
    });

    return response.data;
}
```
이상은 refactoring 전 부분입니다. 위에 말했던 것처럼 token을 세션 스토리지에서 불러오고, 여기서 Bearer 접두사를 제거하는 부분, 그리고 headers 내에 'Authorization': token 부분이 중복되고 있다는 것을 확인할 수 있습니다.

이 부분에서 알아야 할 점은 Scope 개념이 되겠네요. 각 함수의 내부에서 token을 선언하고 Bearer 접두사를 제거하고 있기 때문에 함수마다 선언 및 초기화를 하는 것 같습니다.

## 중복 코드 리팩토링
```ts
import axios, { AxiosRequestConfig } from "axios";
import { CarResponse, Car, CarEntity } from "../types";

const getAxiosConfig = () : AxiosRequestConfig => {            //자료형이 AxiosRequestConfig
    const token = sessionStorage.getItem('jwt')?.replace('Bearer', '');

    return {
        headers:{
        'Authorization': token,
        'Content-Type': 'application/json',
        },

    };
};
export const getCars = async (): Promise<CarResponse[]> => {
    
    const response = await axios.get(`${import.meta.env.VITE_API_URL}/api/cars`, 
    getAxiosConfig());

    return response.data._embedded.cars;

    }; 



export const deleteCar = async (link: string) : Promise<CarResponse> => {
    const response = await axios.delete(link, getAxiosConfig());
    return response.data
}

export const addCar = async (car: Car) : Promise<CarResponse> => {    // 보낼때는 Car 자료형, 돌아올때는 CarResponse 자료형
    const response = await axios.post(`${import.meta.env.VITE_API_URL}/api/cars`, car, getAxiosConfig());

    return response.data;
}


export const updateCar =async(carEntity: CarEntity): Promise<CarResponse> => {
    const response = await axios.put(carEntity.url, carEntity.car, getAxiosConfig());

    return response.data;
}
```
이상에서 고려할 점은 getAxiosConfig의 return 타입으로 사용된 AxiosRequestConfig입니다.

-AxiosRequestConfig : Axios 라이브러리에서 HTTP 요청을 만들 때 사용되는 구성 객체 타입 정의에 해당함. 즉, Axios를 경유하여 요청을 보내기 위해 필요한 _모든 옵션_ 을 담는 일종의 interface에 해당함.

-저희는 axios.post(), .get ...과 같은 방식으로 사용합니다. 이는 좀 더 가독성을 높이기 위한 방식으로 _메서드 별 요청_ 에 해당합니다. 이 경우 endpoint 다음에 두 번째 argument로 사용됩니다.

1. 메서드 별 요청
```ts
//GET요청이라고 가정
axios.get('http://localhost:8080/api/cars', {headers:{'Authorzation':token}});
```
2. 일반적인 요청 방식이 있습니다.
```ts
axios({
  method: 'get',
  url: 'http://localhost:8080/api/cars',
  headers: {
    'Authorization': token,
  }
});
```
이상의 1,2 과정 중에 return 타입에 객체 형태로 옵션들을 담을 수 있는 것을 AxiosRequesetConfig라고 합니다. 저희는 1번 방법을 사용했기 때문에 AxiosConfig() 함수의 정의가 간단한 편에 속했습니다. 2번 방법이면 method 키의 value를 지정하는게 복잡했겠네요.

인터셉터(interceptor)에서의 활용 : request interceptor는 요청이 서버로 가기 전에 가로채서 구성을 수정합니다. 즉 getAxiosConfig() 함수 요청을 하게되면 처음에는 token이 없는 상태로 DB까지 가게 될 뻔했는데, 얘가 중간에 가로채서 headers를 추가해준다는 의미가 되겠습니다.

## Authentication 실패 시 오류 메시지를 토스트 메시지로 응용하겠습니다.

```tsx
 <Snackbar 
        open={open}
        autoHideDuration={3000}
        onClose={() => setOpen(false)}
        message='ID 혹은 비밀번호가 틀렸습니다.'
/>
```
라고 설정을 했다고 가정했을 때, 우리는 setOpen(true)를 호출하는 부분이 필요할 것 같습니다.
Login 컴포넌트 중 어떤 동작을 했을 때 toast message가 출력되어야하며, 그래서 setOpen(true)코드를 삽입해야하는 부분은 어디일까요.

shoppinglist의 Backend 짜기
-Spring Initializer부터 

todolist의 Frontend 짜기
-vite project의 생성부터










