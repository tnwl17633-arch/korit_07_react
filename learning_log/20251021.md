Backend -> cardatabase2를 기준으로 합니다.
Frontend -> carfront를 기준으로 합니다.

둘 다 켜면 현재 getCars() 함수를 불러와서 초기 페이지에 자동차 세 대 데이터가 나옵니다.
CommandLineRunner에 집어넣은 더미 데이터를 불러왔다고 할 수 있음.

# 환경 변수 이용
서버 URL은 CRUD 기능을 만들 때 소스 코드에서 여러 번 반복될 수 있으며, 백엔드가 배포가 되면 localhost:8080이 아니기 때문에 환경 변수로 미리 정의해두는 것이 좋습니다.
예를 들어서 수정이 이루어지고 나면 갱신된 GetCars()가 다시 요청되어야 할겁니다. 그러면 수정 부분에 있는 localhost:8080과 다시 getCars()를 요청할 때의 localhost:8080을 매번 URL로 전부 다 고치는 것은 비효율적입니다(그리고 이건 하드코딩에 해당합니다).

그래서 환경변수에 URL을 저장해두게 되면, URL이 바뀔 때 환경 변수만 수정해주면 일괄 변환이 될 것이기 때문에 환경 변수 설정을 미리 하고 다음 과정으로 넘어가겠습니다.

vite project 상에서는 환경 변수 이름은 `VITE_`로 시작해야 합니다. 
접두사가 VITE_인 변수만 소스 코드에서 접근이 가능합니다.

1. 앱의 루트 폴더에 `.env`파일을 생성

`VITE_API_URL=http://localhost:8080`

2. src 폴더 내에 api 폴더 생성 -> carapi.ts파일 생성
 - 이상은 모든 API 호출 함수를 자체 모듈로 분리하는 과정입니다. 즉 현재 상황에서는 getCars()를 Carlist 컴포넌트에서 분리해오겠다는 의미가 되겠습니다.

 -.env 파일이 src 내부에 있는 경우가 많았습니다. 가장 상위에 둘 것. 

 # 페이징 / 필터링 / 정렬 추가
 -github 때는 Ag Grid 썼는데, 이번에는 MUI 기준으로 작성해보도록 할 예정입니다.
 -터미널에서 npm install @mui/x-data-grid@8.4.0

 # 삭제 기능 추가

 -이제 중요한 점은 삭제를 하기 위해서는 특정 row를 선택해야 한다는 점과, 엔드포인트에 {id}가 추가되어야 한다는 점일겁니다.

 -근데 우리는 각 row에 대한 href를 가지고 있다는 점에 주목할 필요가 있습니다. 
 ```json 
{
    "_embedded": {
        "cars": [
            {
                "brand": "Kia",
                "model": "Seltos",
                "color": "Chacol",
                "registrationNumber": "370SU5690",
                "modelYear": 2020,
                "price": 30000000,
                "_links": {
                    "self": {
                        "href": "http://localhost:8080/api/cars/1"
                    },
                    "car": {
                        "href": "http://localhost:8080/api/cars/1"
                    },
                    "owner": {
                        "href": "http://localhost:8080/api/cars/1/owner"
                    }
                }
            } 
```
HATEOAS를 적용했기 때문에 각각의 id값이 자동으로 설정되어있습니다. 즉 DELETE method를 _links.self.href로 보내주면 알아서 삭제가 될거라고 생각될 수 있겠습니다.

그래서 현재 GET 요청을 통해서 'import.meta.env.VITE_API_URL/api/cars'를 하게 됐을 때 x-data-grid에 의해서 각 자동차 row들이 나와고 있습니다. x-data-grid의 GridColDef를 수정하여 버튼을 하나 추가하고, 거기에 삭제 기능을 적용할겁니다.

왜냐면 key 속성에 이미 _link.self.href 값이 있기 때문입니다.

GridColDef에 딸린 columns 상수를 수정하여 하나의 column을 추가했습니다.
여기에는 Delete 버튼을 할당했습니다. 다른 컬럼들과 달리 세세한 커스텀이 필요하기 때문에 renderCell 컬럼 속성을 사용하여 셀의 컨텐츠가 렌더링되는 방식을 정의했습니다(여기서는 button 태그를 집어넣었습니다).
그리고 현재 상황에서는 alert을 통해 _links.self.href를 불러오는지를 확인했는데, 여기서 중요한 개념이 
onClick={alert(_links.self.href)}를 쓰게 되면 애초에 함수의 결과값이 출력될거기 때문에 버튼을 누르는 것과는 상관이 없다는 결과가 나올겁니다.
onClick={() => alert(_links.self.href)}과의 차이점을 명확하게 알 필요가 있습니다.

함수의 이름을 이벤트 핸들러에 전달 / 함수의 결과를 이벤트 핸들러에 전달하는 것의 차이점을 복습할 필요가 있습니다.
-> 그리고 매개변수가 존재하는 함수의 이름만 전달하는 방법이 무엇일까를 고려하셔야 합니다.

button 태그 내에 sort / filter를 비활성화 시켰고, 컬럼의 메뉴를 비활성화 시키는 disableColumnMenu를 true로 설정했습니다.
그리고 onClick 이벤트도 설정했습니다.

다음 과정을 좀 고민해봐야 합니다. 각 row들마다 href가 존재하기 때문에 delete 요청을 날릴 수 있을 것 같습니다.

현재까지의 코드를 확인해본 결과, 일단 cardatabase_2를 기준으로 지금 back-front 연결을 하고 있는 것은 맞는데, 얘가 Spring Data REST를 기반으로 하고있다보니가 로직 설명이 되고있지 않다는 것을 알 수 있습니다.

즉, 코드 자체를 보고 로직을 떠올리기 위해서는 cardatabase_4의 CarController와 CarService를 확인할 필요가 있습니다.

Axios의 delete 메서드를 이용하여 DELETE 요청을 보낼건데, DELETE 요청의 경우에는 id값이 필요하다는 것을 CarService에서 확인할 수 있었습니다.
그런데 id값은 어디에 있다? href에 있다.

그리고 우리는 함수들을 frontend에서 다 분리를 했습니다, 그렇다면 deleteCar 함수를 작성해야하는 파일은 어디가 될까요

```ts
import axios from "axios";
import { CarResponse } from "../types";

export const getCars = async (): Promise<CarResponse[]> => {
    const response = await axios.get(`${import.meta.env.VITE_API_URL}/api/cars`);
    
    return response.data._embedded.cars;
}

export const deleteCar = async (link: string) : Promise<CarResponse> => {
    const response = await axios.delete(link);
    return response.data
}
```
getCars()의 return 타입과 deleteCar()의 return 타입의 차이를 생각할 필요가 있습니다. getCars()의 경우 자동차들의 정보를 담고있는 배열만 가지고 와서 그것을 Carlist 컴포넌트의 return에 표기하면 되는 반면에, 삭제 후에는 GET 요청 이후의 완전한 JSON이 return 될 필요가 있습니다.
그 차이로 인해서 ._embedded 유무가 결정나는 겁니다.

현재 deleteCar() 메서드를 호출하기 위해 useMutation() hook을 적용했습니다. 그리고 삭제 버튼을 눌렀을 떄, 삭제가 DB에서는 됐지만 frontend 상에서는 새로고침을 해야지만 이루어진다는 점도 확인되죠.

그렇다면 onSuccess는 삭제 이후에, 새로 프론트엔드에 갱신된 cars 정보를 가지고 오는 것이 될겁니다.

즉, 이제 구현할 부분은 자동차가 삭제되면 프론트엔드를 자동으로 새로고침할 수 있도록 하는 것입니다.
react query에서 가져온 데이터는 쿼리 클라이언트가 처리하는 캐시에 저장됩니다. 쿼리 클라이언트에는 데이터를 _다시 가져오는 데 이용할 수 있는 쿼리 무효화_ 기능이 있습니다. 

물론 useEffect()에서 콜백함수를 통해 getCars()를 호출하는데, [cars]를 통해서 cars의 상태가 변화될 떄마다 재렌더링을 일으키는 방법도 있을겁니다. 그런데 현재 저희가 작성한 방식을 봤을 때, useState를 사용하지 않았고, useQuery를 통해서 getCars()를 불러오고 있는 상황이기 때문에 cache에 cars 데이터가 저장돼있을거란 점을 이용해서 코드를 작성할겁니다.

쿼리 무효화 기능을 적용하기 위해 먼저 현재의 쿼리 클라이언트를 반환하는 useQueryClient 훅 함수를 가져왔습니다.
```tsx
import { useQuery, useMutation, useQueryClient } from "@tanstack/react-query";
import { getCars, deleteCar } from "../api/carapi";
import { DataGrid, GridColDef, GridCellParams } from "@mui/x-data-grid";

function Carlist() {
  const queryClient = useQueryClient();             // 이 부분입니다.
  const { data, error, isSuccess } = useQuery({
    queryKey: ["cars"],
    queryFn: getCars
  });
```
# 토스트 메시지 표시
이상에서 구현한 부분은 삭제를 했을 때, cache를 확인하여 최신 정보를 가지고 오는 방식을 택했습니다. 하지만 1번 id를 가지는 애를 삭제했을 때야 바로 위에 뭐가 없어졌는지 보이겠지만 20개 중에 12번 쯤 되는 애를 삭제하면 렌더링 됐을 때 다시 1번부터 나올거니까 제대로 지워졌는지를 체크하기 힘들 것 같습니다.

즉 UX의 개선을 위하여 삭제가 되었다고 표시를 해주도록 하겠습니다.
그런데 alert은 아니라 다른 방식으로.

### SnackBar
-여러분들이 주목해야 할 것은 저희가 shoppinglist 앱에서 도입했었던 Modal과 유사한 성질을 지니고 있다는 점입니다. 그래서 동일하게 
`const [open, setOpen] = useState(false);`
그렇다면 특정 상황이 발생했을 때 setOpen(true)를 통해서 메시지를 출력하고, 다시 setOpen(false);를 통해서 그 메시지가 사라져야겠네요.

shoppinglist에서는 add item 버튼을 누르면 open이 true로 바뀌어서 modal창이 렌더링됐습니다.

그러면 삭제 후에 삭제되었다고 메시지를 띄우고 싶다면, Carlist에서 어느 부분에 setOpen(true);가 있어야 할까요.






# useMutation
```ts
import { useMutation } from "@tanstack/react-query";
// useMutation이 return 하는 객체에는 이 세가지 말고도 여러 속성값이 있습니다.
const { data, isLoading, mutate } = useMutation(mutationFn, options);
useQuery가 GET 요청으로 데이터를 불러 오는데 사용된다면 useMutation은 React Query를 이용해 서버에 데이터 변경 작업을 요청할 때 사용합니다. isLoading 과 data는 useQuery와 같이 완료 여부와, 데이터를 반환하지만 mutate은 mutationFn으로 제공된 함수를 작동시키는 트리거 함수입니다.

useMutation에 들어가는 인자 값

mutationFn: 데이터를 수정하고 업데이트하고 삭제하는데 사용할 함수입니다. fetch나 axios를 사용하여 promise를 반환하는 함수가 와야합니다.
options: useMutation에도 많은 옵션이 있지만 많이 쓰는 4가지 옵션이 있습니다.
onMutate: Promise 객체를 반환하는 Callback 함수로써 mutation 함수가 실행되기 전에 실행되고 mutation 함수와 동일한 변수가 제공됩니다.
onError: mutation이 실패한 경우 실행할 Callback 함수 입니다.
onSettled: mutation이 실패 또는 성공 여부에 관계 없이 실행할 Callback 함수 입니다.
onSuccess: mutation이 성공한 경우 실행할 Callback 함수 입니다.
아래는 실제 사용 예시입니다. // getPosts 함수는 게시물 목록을 가져오는 함수입니다. export const getPosts = async () => { const { data }= await axios.get("http://localhost:8080/post"); return data; };

// createPost 함수는 게시물을 생성하는 함수입니다. export const createPost = async (title, content) => { await axios.post("http://localhost:8080/post", { title, content, }); };

import { useMutation, useQuery, useQueryClient } from "@tanstack/react-query"; import { getPosts, createPost } from "./api.js"

export default function App() { const queryClient = useQueryClient(); const { isLoading, data: posts } = useQuery("posts", getPosts); const createMutate = useMutation( ({ title, content }) => { createPost(title, content); }, { onSuccess: () => { // 비동기 통신이 성공적으로 이루어 졌을때 // posts 라는 queryKey를 찾아 데이터를 새로 받아옵니다. queryClient.invalidateQueries("posts"); }, } );

const handleSubmit = async (e) => {
e.preventDefault();
const { title, content } = e.target;
	
	// 위에서 선언한 createMutate의 mutate함수를 사용하여 createPost 함수를 실행시킵니다.
createMutate.mutate({ title: title.value, content: content.value });
};

return (

{...중략} {isLoading ? "LOADING..." : posts.map((post, index) =>
{${index}) ${post.title}}
)}
); }
``` 
app.jsx​useMutation를 사용해 생성, 업데이트, 삭제 등의 처리 할 수 있고, queryClient가 검색할 수 있는 Query key라면 queryClient.invalidateQueries(queryKey)를 통해 데이터를 손쉽게 갱신 해 줄 수 있습니다. 데이터를 갱신하는 방법은 이 밖에도 여러가지 방법이 있지만 여기서는 invalidateQueries 만 다루어 보았습니다. 이 밖에도 React-Query의 가능성은 무궁무진합니다. 해당 라이브러리에 대해 조금 더 알고 싶다면 공식 사이트를 방문해 주세요.


노션 링크에 보면 react-query 부분의 useQuery / useMutation 부분을 확인하세요.

### confirm 상자 추가하기

button 태그 수정할겁니다.

```tsx
// Carlist.tsx
import { useQuery, useMutation, useQueryClient } from "@tanstack/react-query";
import { getCars, deleteCar } from "../api/carapi";
import { DataGrid, GridColDef, GridCellParams } from "@mui/x-data-grid";
import { Snackbar } from "@mui/material";
import { useState } from "react";

function Carlist() {
  const [ open, setOpen ]  = useState(false);
  const queryClient = useQueryClient();
  const { data, error, isSuccess } = useQuery({
    queryKey: ["cars"],
    queryFn: getCars
  });

  const { mutate } = useMutation(deleteCar, {
    onSuccess: () => {
      setOpen(true);
     queryClient.invalidateQueries({ queryKey: ["cars"]});     // 이 부분은 useQuery()를 정의한 부분과 관련있습니다.
    },
    onError: err => {
      console.log(err);
    },
  })

  const columns: GridColDef[] = [
    {field: 'brand', headerName: 'Brand', width: 200}, 
    {field: 'model', headerName: 'Model', width: 200}, 
    {field: 'color', headerName: 'Color', width: 200}, 
    {field: 'registrationNumber', headerName: 'Reg.nr', width: 150}, 
    {field: 'modelYear', headerName: 'Model Year', width: 150}, 
    {field: 'price' , headerName:'Price' , width: 150}, 
  {
    field: 'delete',
    headerName: '',
    width: 90,
    sortable: false,
    filterable: false,
    disableColumnMenu: true,
    renderCell: (params: GridCellParams) => (
      <button
        onClick={() => {
          if(confirm(`${params.row.brand}의 ${params.row.model} 자동차를 삭제하시겠습니까?`)) {
            mutate(params.row._links.self.href);}} // 함수의 이름만 전달하기 위해 화살표(=>) 사용
          }
          
      >
        Delete
      </button>
    )  
    }
  ];

  if(!isSuccess) {
    return <span>Loading... 🐢</span>
  }

  if(error) {
    return <span>자동차들을 불러오는 데 실패했습니다.😭 </span>
  }
  else {
    return (
      <>
      <DataGrid
      rows={data}
      columns={columns}
      getRowId={row => row._links.self.href}
      />
      <Snackbar
      open={open}
      autoHideDuration={2000}
      onClose={() => setOpen(false)}
      message= '선택한 자동차 정보가 삭제되었습니다.😺' 
      />
      </>
    )
  }
}

export default Carlist
```

# 생성 기능 추가
MUI 모달 폼을 이용하여 Car row를 추가할 수 있도록 할 예정
New Car라고 하는 버튼을 추가하여 버튼을 누르면 모달 폼이 열리게 할 것임.
그러면 모달 폼 내에는 여러 개의 input이 있어서 entity 상에서 final/@Nonnull이 있는 field에 대한 모든 입력을 받고, 이를 저장하거나 취소할 수 있는 버튼을 내부에 구현할 예정임.

shopping list에서 add item 버튼과, 그 내부 모달 폼 형식을 참조할 수 있을 것 같음.
```tsx
//AddCar.tsx
import { Dialog, DialogActions, DialogContent, DialogTitle } from "@mui/material";
import { Car } from "../types";
import { ChangeEvent, useState } from "react";

function AddCar() {
  const [ open, setOpen ] = useState(false);
  const [ car, setCar ] = useState({
    brnad: '',
    modal: '',
    color: '',
    registrationNumber: '',
    modalYear: 0,
    price: 0
  });
  
  const handleClickOpen = () => setOpen(true);

  const handleClickClose = () => setOpen(false);

  const handleChange = ( event: ChangeEvent<HTMLInputElement>) => 
    {
    setCar({...car, [event.target.name]: event.target.value});
    }

   



  return(
  <>
  <button onClick={handleClickOpen}>New Car </button>
  <Dialog open={open}>
    <DialogTitle>New Car🚕</DialogTitle>    
    <DialogContent>
      <input type="text" name="brand" value={car.brand} placeholder="Brand" onChange={handleChange} /><br />
      <input type="text" name="model" value={car.model} placeholder="Model" onChange={handleChange} /><br />
      <input type="text" name="color" value={car.color} placeholder="Color" onChange={handleChange} /><br />
      <input type="text" name="registrationNumber" value={car.registrationNumber} placeholder="Reg.No" onChange={handleChange} /><br />
      <input type="text" name="modelYear" value={car.modelYear} placeholder="Year" onChange={handleChange} /><br />
      <input type="text" name="price" value={car.price} placeholder="Price" onChange={handleChange} /><br />
    </DialogContent>
    <DialogActions>
      <button onClick={handleClickClose}>Cancel | 취소</button>
      <button onClick={handleClickClose}>Save | 저장</button>
    </DialogActions>
  </Dialog>
  </>
  );
}

export default AddCar;
```
나중에 전부 html 태그를 mui로 갈아끼울겁니다.
현재까지 작성했을 때 브라우저 상에서의 화면은 어느 정도 구현되었습니다.
그럼 현재까지의 상황에서 이후의 작성 순서는 
axios.post를 통해서 db로 지금 데이터값을 넘겨서 저장할 수 있어야할 것이고,
저장이 완료되었다면 갱신된 getCars()를 호출해야합니다.
또한 저장/취소가 된 이후에 input창이 초기화되는 것도 고려해볼만합니다.
(그러면 수정 때는 초기화된 input이 아니라 기존 값들이 불러와져야겠네요)









