## TypeScript로 리액트 앱 만들기 실습 예제
```tsx
import { useState } from 'react'
import './App.css'

function App() {
  const [ name, setName ] = useState('');
  const handleChange = (event : React.ChangeEvent<HTMLInputElement>) => {
    setName(event.target.value);
  }

  const handleSubmit = (event : React.FormEvent<HTMLFormElement>) => {
    event.preventDefault();
    alert(`Hello ${name} 😊`);
  } 
  

  return (
    <>
    <form onSubmit={handleSubmit}>
      <input type="text" value={name} onChange={handleChange}/>
      <input type="submit" value='제출'/>
    </form>
    </>
  )
}

export default App
```

# React RESTFful API 구현
리액트를 이용한 네트워킹 실습을 할 예정. cardatabase를 기준으로 다양한 react 적용 기술들을 jsx/tsx로 구현할 것이고 이를 위해서 특히 네트워킹 파트에 fetch 및 axious를 실습함. 이는 비동기 코드를 더 깔끔하고 가독성있게 만들ㄹ 수 있는 Promise 개념에 대해서 사전 학습이 되어있어야만 가능

Promise 역시도 js에 딸려있는 기능 중 하나였지만 그때는 설명하지 않았음.

react-query를 라이브러리를 이용하여 실제로 작동이 어떤식으로 이루어지는지에 대한 설명도 할 예정

## ts 프로젝트 생성
1.weatherapp - react - jsx 형태로 생성
2.App.jsx 초기화
3.npm run dev를 통해서 빈 브라우저 화면 출력

이상을 이용해 간단한 RESTful API 구현을 하도록 하겠음.

## Promise
- 비동기 연산을 처리하는 방법으로, 전통적인 방법은 연산의 성공 또는 실패에 대한 callback function을 작성해두는 것입니다. 예를 들어 GET 요청을 했다고 가정했을 때 이에 성공했다면 sucess() 함수를 호출하고, 실패했을 때는 failure() 함수를 호출하는 것처럼요. 이하는 이를 추상적으로 작성한 예시입니다.

```js
function doAsyncCall(success, failure) {
  // 어떤 API 호출

  IF(SUCCEED) {
    success(resp);
  } else {
    failure(err);
  }

  function success(response) {
    // 응답을 가지고 작업 수행
  }

  function failure(error) {
    // 오류를 처리하는 로직
  }
}
```
이상은 예전에 이런 구조로 작성했었다는 의미입니다. 현재의 Promise는 JS에서 비동기 프로그래밍의 기본 요소이기 때문에 Promise를 기반으로 한 코딩을 하게 됩니다.
그러면 Promise가 뭐냐? 가 문제가 됩니다.

Promise란? -> 비동기 연산의 결과를 나타내는 JS 객체.

이를 이용하면 비동기 호출을 실행할 때 코드가 좀 단순화됩니다. 얘가 없던 시절에는 코드를 읽고 유지 관리하는게 엄청 골치아팠었습니다. 여러 개의 중첩된 callback function들이 있어야만 했거든요.

요청을 전송하는 데 이용하는 API 또는 라이브러리가 프로미스를 지원하는 경우, 프로미스를 이용한 비동기 호출을 실행할 수 있습니다(오늘날에는 대부분 지원). 이하에서는 비동기 호출 수행 관련 예제입니다.

```jsx
doAscyCall().then(response => 뭐 어떤 로직);
```

즉, 아까 위에위에 js함수 정의를 했던 부분들 중에, doAsycCall()의 내부에서 if절 부분이 다 필요 없어지는 작성 방식이라고 할 수 있음.

이상의 호출 부분을 해석하기 위해서는 method의 결과가 return 되고, 이것이 다음 .then() 메서드를 실행하는 객체가 된다는 점을 이해하고, builder 패턴에서 처음 배웠던 chaining method 개념이 익숙하다면 충분히 해석할 수 있을것임.

응답이 반환됐을 때, then() 메서드 내부에 callback 함수가 실행되어 응답을 argument로 받게 됩니다(그래서 예시에 response라는 매개변수 명을 달아놨습니다).

그렇다면 여기서 의문을 가져야 하는 점은 then() 메서드의 return 자료형이겠네요.

then() 메서드의 return 자료형: Promise.
그리고, 이 Promimse는 세 가지 상태 중 하나에 속함.
1. 대기(Pending) : 초기 상태
2. 이행(Resolved) : 작업 성공
3. 거부(Rejected) : 작업 실패

이하의 예시는 프로미스를 단순화시킨 형태로, 특히 setTimeout을 활용하여 비동기 연산을 시뮬레이션했습니다.
```js
const myPromise = new Promise((resolve, rejet) = {
  setTimeout(() => {
    resolve('Hello');
  }, 500); 
});
```
1. JS에서도 생성자를 통한 객체 생성이 가능함. 즉, 96번 라인에서는 저희가 myPromise라는 객체를 생성했다고 할 수 있습니다.
2. 해당 myPromise 객체는 resolve 매개변수와 reject 매개변수를 가집니다.
3. 프로미스 객체가 생성될 때와 타이머가 실행되는 동안 프로미스는 대기 상태에 있습니다. 그리고 500 밀리초가 지나면 'Hello`라는 값으로 resolve 함수가 호출되고, 프로미스는 _이행_ 상태로 갑니다. 오류가 발생하면 _거부_ 상태로 넘어가겠네요. 현재는 _거부_ 에서 처리하는 로직을 작성하지 않았습니다.

그리고 이상에서 배웠던 .then() 메서드를 통해 인스턴스를 서로 연결하여 다수의 비동기 작업을 _순차적으로_ 진행시키는 것이 가능합니다.
```js
doAsyncCall() . then(response => 전체 응답 결과가 나온 것을 가지고 비지니스 로직 수행).then(data => response를 가공한 결과값을 매개변수 data로 이름 붙이고 추가적인 비지니스 로직 수행)
```
그리고 rejected된 상태에서의 오류 처리를 추가하는 것이 가능합니다.
```js
doAsyncCall() 
. then(response => 전체 응답 결과가 나온 것을 가지고 비지니스 로직 수행)
then(data => response를 가공한 결과값을 매개변수 data로 이름 붙이고 추가적인 비지니스 로직 수행)
.catch(error => console.log(error));
```
그러면 저희가 Java에서 배웠던 예외처리 방법에서처럼 doAscyCall()과 두 개의 .then() 메서드들 중에서 어디에서라도 오류/예외가 발생하면 catch 부분으로 넘어가게 됩니다.

개발자는 콘솔에 찍힌 error를 보고 이를 수정하게 될겁니다.

## async / await
비동기 호출을 처리하는 좀 더 최신 방식은 ECMAScript2017에 도입된 async/await를 이용하는 방식입니다. 이는 Promise에 대한 개념을 알고 있다는 전제 하에 사용하는 것이 정신건강에 좋습니다. 얘를 쓰려면 await 표현식을 포함할 수 있는 async() 함수를 정의해야하거든요 ..

이하는 async / await의 비동기 호출 예시입니다.
```jsx
const doAsyncCall = async () => {
  const response = await fetch('http://someapi.com');
  const data = await response.json(); 
 // 그리고 data를 가지고 로직 수행하는 부분을 정의
}
```
여기서 fetch() 함수가 나오는데, 얘의 return 값도 Promise입니다. 다만, async / await를 도입했을 경우 .then()을 쓰는 것이 아니라 await 키워드를 써야 합니다.

그리고 오류 처리를 위해서 마찬가지로 async / await에 try-catch 문을 쓸 수도 있습니다. 이하는 그 예시입니다.
```js
cpmst doAsyncCall = async () => {
  try {
    const response = await fetch('http://someapi.com');
    const data = await response.json();
    // data를 가지고 추가적인 비지니스 로직 정의
  }
  catch {
    console.log(error);
  }

}
```
이상까지가 전반적인 Promise의 정의와 사용 최근 사례입니다.
이를 이용하면 React 앱에서 request 작업에서 사용하는 fetchAPI에 대해서 학습할 준비가 된겁니다.

## fetch API 이용
JS 상에서의 fetch API 개념은 기존의 XMLHttpRequest 혹은 jQuery Ajax API와 유사한데, fetch API가 좋은 점은 Promise를 지원한다는 점입니다. 그리고 react 내장 API라서 추가적인 설치가 필요 없다는 점도 장점입니다.

fetch API는 아까 위에서 봤던 fetch() 메서드를 제공함. 웹 요청의 경우에 argument는 서비스의 URL이 됩니다.
그래서 이제 저희는 처음으로 _GET요청_ 을 react에서 하는 예시를 작성하게 될겁니다.

```jsx
fetch('http://someapi.com')
.then(response => response.json())
then(data => console.log(data))
.catch(error => console.log(error));
```
fetch() 메서드는 response가 포함된 프로미스를 return함. 이를 .json() 메서드를 활용하여 JSON 데이터를 추출하고 , 이 메서드 역시 프로미스를 반환함(아까 위에서 적었음. then 메서드의 결과값이요.)

이상의 의사 코드에서 160번 라인의 then 문에 전달되는 response는 요청이 성공했는지 확인하는 데 이용하는 ok 및 status 속성을 포함하는 객체임. 응답 상태가 2xx 형식이라면 ok 값 속성은 true로 return됨.

```jsx
fetch('http://someapi.com') // 얘가 성공적으로 fetch가 이루어졌다면 response라는 얘가 결과값으로 나오고
.then(response => {             // 그 response를 가지고 연산을 하겠다는 의미로 해석하시면 됩니다.
  if(response.ok) {
    // 요청 성공 -> 상태 2xx
  }
  else {
    // 문제 발생 -> 오류 응답(401, 404, 500 etc)
  }
  })
.then(data => console.log(data))
.catch(error => console.log(error));
```


POST와 같은 다른 HTTP 메서드를 이용하려면 fetch() 메서드의 두 번째 argument에 해당 메서드를 정의해야합니다.
두 번째 argument는 여러 요청 설정을 정의할 수 있는 _객체_ 입니다. 그래서 이하의 예시는 POST 요청에 대한 부분입니다.

```jsx
fetch(`http://someapi.com`, { method: 'POST'})
.then(response => response.json)
.then(data => console.log(data))
.catch(error => console.log(error)); 
```
근데 저희가 postman에서 해봤던 것처럼 특정한 자격이 있거나 특정 형식으로 headers를 추가할 필요가 있었음.
그럼 fetch()의 두 번째 argument인 객체에 key-value properties를 추가함으로써 해결할 수 있음.
이하의 예시는 Content-Type : application/json 헤더를 추가해보도록 하겠음.
```jsx
fetch(`http://someapi.com`, 
  {
     method: 'POST',
     headers: {'Content-Type': 'application/json'}
  })                                           // 우리가 postman에서 작업했던 부분이라고 할 수 있음
.then(response => response.json)
.then(data => console.log(data))
.catch(error => console.log(error)); 
```
요청 본문 내에 JSON으로 인코딩된 데이터를 보내는 경우도 있겠죠.

```jsx
fetch(`http://someapi.com`, 
  {
     method: 'POST',
     headers: {'Content-Type': 'application/json'},
     body: json.stringify(data)
  })
.then(response => response.json)
.then(data => console.log(data))
.catch(error => console.log(error)); 
```

대충 나중에 복습할 fetchAPI가 복잡하다는 것은 아실텐데, 얘가 또 유일하게 요청을 수행하는 방법인건 아닙니다.
다수의 경우에는 axios라는 외부 라이브러리를 활용합니다.

## axios 라이브러리 이용
axios는 fetchAPI처럼 네트워크 호출과 관련된 라이브러리입니다. 즉, POST / GET / PUT / DELETE와 관련있다고 보시면 되겠습니다. 

-여기서 특정 라이브러리를 사용하게 될 경우 우리는 추가 설치를 해야할 경우가 있습니다.

npm install axios

axios 라이브러리에는 JSON 데이터의 자동 변환과 같은 이점을 지니고 있습니다. 그래서 fetch()에서 response.json() 메서드를 호출했던 것과 같은 과정이 필요없습니다.

```jsx
axios.get('http://someapi.com')
.then(response => console.log(response))   // fetch API를 썼을 때보다 then 절 하나가 줄었습니다.
.fetch(error => console.log(error));
```

POST 요청을 할 때는 axios.post()를 쓰겠네요.
```jsx
axios.post('http://someapi.com', { 어떤 새로운 객체 })
.then(response => console.log(response))
.catch(error => console.log(error));
```
axios() 함수를 이용하게 되면 method / headers / data / url 등의 세부 정보를 지정하는 객체를 전달하는 것도 가능합니다.

```jsx
const resonse = await axios({
  method: 'POST',
  url: 'httpsL//myapi.com/api/cars',   
  headers: {
    'Content-Type': 'application/json'
  },
  data: { brand: '현대', model: 'GV80' }
});
```
그래서 이상의 예시는 https://myapi.com/api/cars 엔드포인트로 POST 요청을 보냈는데, 요청 본문에 객체가 포함되고, Axios가 자동으로 이를 문자열화(stringify)해줍니다.

## 실전 예제 weatherapp
### OpenWeather API 도입
https://openweathermap.org

REST API를 이용하는 경우 응답을 검사하여 JSON 데이터의 포맷을 확인해야 합니다. 즉 날씨 정보를 OpenWeather API로 활용할겁니다.


https://api.openweathermap.org/data/2.5/weather?q=Busan&units=Metric&APIkey=c082350156ede7817b644f04f85cebfc

https://openweathermap.org/img/wn/04d@2x.png
을 깃허브에 올리겠음
여기서 04d가 icon key의 value로 잡혀있고, img파일을 불러오기 위해서는 @2x.png를 붙여줘야함

```jsx
import { useEffect, useState } from 'react'
import './App.css'

function App() {
  const [ weather, setWeather ] = useState({
    temp: '',
    desc: '',
    icon: ''
  }); 
  
  useEffect(() => {
    fetch('https://api.openweathermap.org/data/2.5/weather?q=Busan&units=Metric&APIkey=c082350156ede7817b644f04f85cebfc')
    .then(response => response.json())
    .then(result => {
      setWeather({
        temp: result.main.temp,
        desc: result.weather[0].description,
        icon: result.weather[0].icon
      })
    })
    .catch(error => console.log(error))
  }, []);

  if(weather.icon) {
    

  

    return (
    <>
      <p>기온 : {weather.temp}</p>
      <p>설명 : {weather.desc}</p>
      <img src={`https://openweathermap.org/img/wn/${weather.icon}@2x.png`} alt="날씨 아이콘" />
    </>
    );
  }
  else {
  return <div>Loading ...</div>
  }
}

export default App
```
이상의 코드에서 여러분들이 유념해서 봐야 할 점은 이하와 같습니다.
1. useState()의 초기값으로 JS 객체 형태를 넣었다는 점 -> user 객체 형태로 firstName / lastName / email을 통해서 작성하는 방법을 수업했었습니다.
 - 이 부분이 번거로우면 각각의 상태를 선언하는 방식으로 작성했었구요.

2. useEffect()의 argument 분석입니다.
  -1st argument는 callback function
  -2nd argument는 어느 시점에 리렌더링을 할 것인가를 통제했습니다. []의 의미도 알 필요가 있습니다.
  -callback function의 내부 로직은 fetchAPI를 활용했습니다(axios가 아니라)
  -fetchAPI를 이해하기 위해서는 Promise 개념에 대한 선행이 요구됩니다.

3. useEffect() 가 최초 렌더링 시에 호출이 됐고, 그 결과 callback function이 호출되면, weather라는 상태가 업데이트됐을겁니다. 
 - 이를 확인하기 위한 방법으로 브라우저에서 개발자도구를 열고 Components 탭에서 State를 확인할 수 있었습니다.
 - 또한 실패했다면 Network 탭에서 200 OK가 아니라 오류 메시지가 떴거나, 
 - 저희가 작성한 console.log(error)로 인해서 콘솔 창에 오류 메시지가 떴을겁니다.

4. 상태가 업데이트 됐음을 확인했다면, 이를 브라우저에 표시해주기 위해 return을 작성했습니다.
 - icon이 img 파일이기 때문에 loading 시간이 가장 길 것이라고 판단, 그래서 icon의 유무에 따라서 조건문 작성을 통해 return 부분을 표시했습니다.

### Github API 도입
1. githubapp 프로젝트 생성
2. App.tsx 초기화
3. npm run dev로 실행하여 빈 화면 띄우시오

이번 예제에서는 키워드로 리포지토리를 가져오는 Github API를 사용할겁니다.
사용자가 input 태그에 키워드를 입력하고 클릭하면 해당 키워드가 포함된 리포지토리를 가져오는 형태가 될겁니다.
이상의 과정에서 axios를 활용하여, axios.get()

```tsx
type MyDataType = {
  id: number,
  name: string
}

axios.get<MyDataType>(apiUrl)
.then(response => console.log(response.data))
.catch(error => console.log(error));
```
그럼 어제 배운 TS의 작성 요령이 익숙할 필요가 있겠습니다.

예상 데이터 타입에 없는 일부 field에 접근하려고 하면 개발 단계 초기에 오류를 포착할 수 있습니다.
이 시점에서 타입스크립트는 자바스크립트로 컴파일링되며 모든 타입 정보가 제거된다는 점을 이해해야 합니다.
따라서 타입스크립트는 런타임 작동에 직접적인 영향을 끼치지 않고, REST API가 예상과 다른 타입의 데이터를 반환하는 경우 타입스크립트는 이를 런타임오류로 포착하지 않습니다.

그래서 TS의 개념을 생각할 때 JavaScript보다 작은 집합이나 혹은 교집합으로 볼 것이 아니라, 
JavaScript로 컴파일링 되기 전에 오류를 포착할 수 있는 filter 역할이라고 현재는 봐주면 될 것 같습니다.

이제 githubapp에서 axios를 사용할거기 때문에
터미널을 켜고
npm install axios

 https://api.github.com/search/repositories?q={KEYWORD}

 q=는 query를 의미 = 다음에 우리가 검색하는 내용의 키워드를 집어넣게되면 그 결과값을 GET 요청으로 가져오게 됩니다.
 즉,우리는 input 창 입력한 내용을 {KEYWORD}에 대입하게 될겁니다.

 이상의 결과값에 들어가게되면, JSON데이터가 나오는데, 그 중 items 키를 확인하면 배여로 이루어져있다는 것을 볼 수 있습니다.

 저희는 이 개별 repository에서 full_name 값과, html_url 값을 가져올 예정임.

 그리고 그 결과값을 map() 함수 이용해서 값을 표의 row로 변환해볼 것임. 그 때 key prop을 집어넣으라고 잔소리할텐데 id가 고유값이라서 얘를 써보겠음

그리고 openweatherapp과 차이점이 좀 있는데, 이번 예제에서는 useEffect() 훅 함수 내부에서 axios.get()을 호출할 수 없습니다. 이는 컴포넌트가 최초 렌더링 되는 시점에는 q={KEYWORD}에 해당하는 값이 없기 때문입니다.

그래서 일단은 사용자 input 창에 대한 상태와 JSON 응답 데이터에 대한 상태를 생성할겁니다.

즉 input창에 값을 입력하면 그 값을 가지고 api에 GET요청을 날리게 되고, 그 결과값을 JSON 응답데이터 상태에 저장하게 되는 순서(weather 상태를 저장한 것처럼) 입니다.

근데 이 전체 JSON 데이터가 배열이라는 점도 미리 알고 지나가겠습니다.
그리고 필요한 field는 뭐다? id / html_url / full_name 이다. 근데 어느 구조인지는 JSON 뜯어봐야겠다.

```tsx
import { useState } from 'react'
import axios from 'axios'
import './App.css'

type Repository = {
  id: number;
  full_name: string;
  html_url: string;
  user_name: string
};

function App() {
  const [ keyword, setKeyword ] = useState('');
  const [ repodata, setRepodata ] =useState<Repository[]>([]);

  const handleClick = () => {
    axios.get<{ items : Repository[] }>(`https://api.github.com/search/repositories?q=${keyword}`)
    .then(response => setRepodata(response.data.items))
    .catch(error => console.log(error))
    }

  return (
    <>
      <input type="text" onChange={e => setKeyword(e.target.value)} value={keyword}/>
      <button onClick={handleClick}> ❤️Search❤️</button>
      {repodata.length === 0 ? (
        <p>No data available</p>
      ) : (
        <table>
          <tbody>
            {repodata.map(repo => 
              <tr key={repo.id}>
                <td>{repo.full_name}</td>
                <td>
                <a href={repo.html_url}>{repo.html_url}</a>
                </td>
              </tr>
            )}
          </tbody>
        </table>
        )}
      </>
  )
}

export default App
```

github API가 요청 횟수 제한이 있습니다. 현재 저희가 별 문제가 없긴 한데, 대충 1분에 10회 정도로 알고 있습니다.
이 한도 넘어가면 또 1분 기다린 후에 테스트 할 수 있습니다.

## React Query 라이브러리 이용
React query -> tanstack Query라고 알려져있음. 데이터 캐싱 및 성능 최적화 관련임.

React Query 활용 react 앱에서 데이터를 가져오는 방법을 쓸건데, github REST API에서 리포지토리를 가져오도록 하겠습니다.

gitapi -> react -> javascript로 생성

npm install @tanstack/react-query@4
npm install axios
npm install
npm run dev 해서 default 페이지 키시오
App.jsx 초기화해서 빈 브라우저 화면을 켜시오

git add .
git commit -m "feat: gitapi app created"
git push

-데이터 캐싱이란?
  -애플리케이션 성능 최적화의 핵심 개념 중 하나로, 네트워크 요청이나 계산 비용이 큰 작업의 결과를 한 번 저장해두고(캐시(cache)), 이후 동일한 요청이 들어올 때 저장된 결과를 빠르게 재사용함으로써 응답 시간(latency)을 단축하고 서버 부하를 줄이는 기법.

  -캐시(cache) : 임시 저장소(메모리, 디스크, 브라우저 스토리지 등)에 데이터를 저장해두는 공간
    -데이터 요청 전: 애플리케이션은 캐시에 해당(URL/쿼리 매개변수)에 대응하는 데이터가 있는지 확인(cache lookup)
    -cache hit: 캐시에 데이터가 있고, 그것이 유효하다면 저장된 값을 즉시 반환
    -cache miss: 캐시에 데이터가 없거나 만료되었으면 원본(원격 API / DB 등)에 요청(fetch) -> 데이터를 받아와서 캐시에 저장한 뒤 client에게 반환

```tsx
import './App.css'
import { QueryClient, QueryClientProvider } from '@tanstack/react-query'

const queryClient = new QueryClient();

function App() {


  return (
    <>
      <QueryClientProvider client={queryClient}>
        
        </QueryClientProvider>     
    </>
  )
}

export default App
```
이상의 코드는 React Query를 사용하기 위한 기초 단계로, React Query는 데이터 캐싱을 처리하는 QueryClientProvider와 QueryClient 컴포넌트를 제공합니다. 이 컴포넌트를 App Component로 가져오는데, QueryClient 객체를 생성 후, App Component에서 QueryClientProvider를 렌더링했습니다.

그리고 React Query는 네트워크 요청을 호출하는 데 이용되는 useQuery 훅 함수를 제공합니다.

-형식 :
```jsx
const query = useQuery({ queryKey: ['repositories'], queryFn: getRepositories })
```
-queryKey : 쿼리를 위한 고유한 키로 데이터의 캐싱과 다시 가져오기에 사용
-queryFn : 데이터를 가져오는 함수이며 프로미스를 반환해야 함(즉, axios나 fetch API와 관련)

useQuery 훅이 반환하는 query 객체에는 쿼리 상태와 같은 중요한 속성들이 포함되어 있습니다.

```jsx
const { isLoading, isError, isSuccess }= useQuery({ queryKey: ['repositories'], queryFn : getRepositories });
```
가능한 상태 값은 이하와 같음
-isLoading : 데이터를 아직 이용할 수 없다.
-isError: 쿼리가 오류로 종료
-isSuccess: 쿼리가 성공적으로 종료되었으며 쿼리 데이터를 이용할 수 있다.

query 객체의 데이터 속성에는 응답이 반환하는 데이터가 포함된다.

그래서 이상의 useQuery() 훅을 활용하여 Github 예제의 repository 정보를 가져오고자 합니다.

Repositories.jsx 컴포넌트를 생성하고, 초기화하시오

```jsx
import { useQuery } from "@tanstack/react-query";
import axios from "axios";

function Repositories() {
  const getGerepositories = async () => {
    const response = await axios.get('https://api.github.com/search/repositories?q=korit_07');
    return response.data.items;
  }

  const { isLoading, isError, data } = useQuery({
    queryKey: ['repositories'],
    queryFn: getGerepositories,
  })

 if(isLoading) {
  return <h1>Loading ... 🐢 </h1>
 } 

 if(isError) {
  return <h1>오류가 발생했습니다... 😥</h1>
 }
 else {
  return (
    <table>
      <tbody>
        {
          data.map(repo => 
          <tr key={repo.id}>
            <id>{repo.full_name}</id>
            <td>
              <a href={repo.html_url}>{repo.html_url}</a>
            </td>
          </tr>
          )
      }
      
      </tbody>
    </table>
  )
}
}

export default Repositories
```
이상을 처리하고 App.jsx에 Repositories 컴포넌트를 QueryClientProvider 컴포넌트 내에 집어넣었을 경우, 아까 전의 githubapp과 동일한 기능을 한다는 것을 확인할 수 있습니다.

이 출력된 리포지토리들은 리액트 쿼리 라이브러리를 이용하여 가져왔음 또한 내장된 기능을 이용하여 요청 상태를 isLoading / isError / data의 형태로 처리하였으며 리액트 쿼리가 데이터 관리와 캐싱을 처리하기 때문에 응답 데이터를 추가로 저장하기 위한 상태의 선언이 필요하지 않음

근데 그 chrome에서 탭을 왔다갔다 하다보면 브라우저가 재포커스가 되는데, 리액트 쿼리에 의해서 다시 불러오기가 실행됨(근데 q=korit_07의 검색 결과가 너무 적어서 빠르게 로딩이 일어남) 그리고 이거랑 아까 말한 github api 자체 정책으로 인해 1분에 10번 이상 GET 요청을 날려버려서 오류가 발생함

그래서 useQuery 내에 staleTime이라고 하는 키가 존재하는데, 이는 데이터가 최신으로 유지되는 시간을 규정함. 
기본적으로는 0으로 잡혀있기 때문에 재포커스가 일어날 때마다 난리가 남.

```jsx
const { isLoading, isError, data } = useQuery({
    queryKey: ['repositories'],
    queryFn: getGerepositories,
    staleTime: 60 * 1000, //1분을 의미
    cacheTime: 60 * 5000,
  })
```
그리고 cacheTime이라는 속성이 있는데 이는 비활성상태인 쿼리들이 garbage collection 대상이 되는 타이밍을 의미.
default로는 5분으로 설정되어있음

이후 mutation 개념이 있는데 이는 cardatabase 구현시에 다시 한 번 설명할 것임

이상까지는 리액트를 활용한 네트워킹과 관련된 수업이었음. 특히 향후의 백엔드와의 연관성을 고려하여 자료형을 설정함. type으로 정의한 얘들이 백엔드로 들어가게 되면 record나 dto 형태로 전달이 될거라고 생각하면 TS에 대한 위화감이 좀 줄어들 것 같음
