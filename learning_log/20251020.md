# 금일 수업 계획
1.서드파티 컴포넌트
- React date picker 를 통한 서드파티 컴포넌트 설치
- AG Grid를 이용한 페이지네이션 및 필터링
- MUI 컴포넌트 이용 라이브러리를 위한 CSS

2.SpringBoot 연동

# full stack 이후 수업 관련 사항
1. Docker 배포
2. Github 팀 관련 수업
3. AWS 배포

# 대기 동안에 새 프로젝트 생성하겠습니다.
1. React-TypeScript로 thirdpartapp 생성하시오.
2. App.tsx를 초기화하시오.

# third party components
chrome -> awesome-react-components

https://github.com/brillout/awesome-react-components

1. 컴포넌트들은 README에서 볼 수 있듯이 npm을 통해서 설치가 가능함
`npm install component_name@version`
`npm install react-date-picker@10.0.3`
-설치된 컴포넌트를 리액트 앱에서 제거하는 명령어
`npm uninstall component_name`
`npm install react-date-picker`
-업데이트가 누락된 컴포넌트들을 전부 다 검색하는 명령어
`npm outdated`
-업데이트가 누락된 컴포넌트드들을 일괄 업데이트하는 명령어
-`npm update`
-모든 프로젝트 의존성 목록을 가져오는 명령어
`npm list`

# AG Grid
`npm install ag-grid-community@30.1.0 ag-grid-react@30.1.0`
AG Grid는 리액트 앱을 위한 데이터 그리드 컴포넌트입니다.
-스프레드시트처럼 데이터를 표시하는 데 이용하며, 상호작용도 가능합니다.
-필터링 / 정렬 / 피벗과 같은 기능들을 포함했습니다.

```tsx
import { useState } from 'react'
import axios from 'axios'
import { AgGridReact } from 'ag-grid-react';
import 'ag-grid-community/styles/ag-grid.css';
import 'ag-grid-community/styles/ag-theme-material.css';
import './App.css'

type Repository = {
  id: number;
  full_name: string;
  html_url: string;
  user_name: string
};

function App() {
  const [ keyword, setKeyword ] = useState('');
  const [ repodata, setRepodata ] =useState<Repository[]>
  const [ columnDefs ] = useState<ColDef[]>([])


  const handleClick = () => {
    axios.get<{ items : Repository[] }>(`https://api.github.com/search/repositories?q=${keyword}`)
    .then(response => setRepodata(response.data.items))
    .catch(error => console.log(error))
    }

  return (
    <div className="App">
      <input type="text" onChange={e => setKeyword(e.target.value)} value={keyword}/>
      <button onClick={handleClick}> ❤️Search❤️</button>
      <div className="ag-theme-material"
        style={{height: 500, width: 850}}
        >
        <AgGridReact rowData={repodata}/>
        </div>
      </div>
  )
}


export default App
```
```tsx
import { AgGridReact } from 'ag-grid-react';
import 'ag-grid-community/styles/ag-grid.css';
import 'ag-grid-community/styles/ag-theme-material.css';
```
이상의 import문들은 ag-grid 컴포넌트 자체와 스타일 시트를 가지고 있음. 그 중에서도 google에서 권장하는 material style을 가지고 왔음을 뜻함.

그러니까 사전 정의 스타일을 가지고 옴으로써 css를 최소화함.
그런데 style/ag-grid.css를 통해 최소한의 커스터마이징도 할 수 있는데, 이를 style={{height:500, width:850}}으로 처리함.

그리고 return문에 AgGridReact 컴포넌트의 추가를 통해 repoData를 가지고 테이블을 작성하려고 함
rowData라고하여 이미 사전에 이름 붙여져있는 속성에 프롭을 전달했음


그리고 ag-grid 컴포넌트 자체는 스타일을 정의하는 div element
```tsx
  return (
    <div className="App">
      <input type="text" onChange={e => setKeyword(e.target.value)} value={keyword}/>
      <button onClick={handleClick}> ❤️Search❤️</button>
      <div className="ag-theme-material"
        style={{height: 500, width: 850}}
        >
        <AgGridReact rowData={repodata}/>
        </div>
      </div>
  )
```
이상과 같은 return문이 작성됨

그 다음 과정으로 ag-grid에 이용될 컬럼을 정의할것임. 컬럼 정의 객체의 배열에 해당하는 columnDefs라는 상태를 정의할것임.그리고 ag-grid는 여기에 이용할 수 있는 ColDef 타입을 제공함(TypeScript로 쓰는 이유). 컬럼 객체에서는 필수 field 프롭을 이용하여 데이터 접근자를 정의해야하는데, 여기서는 field 값이 컬럼이 표시해야 하는 REST API 응답 데이터의 속성 이름이 될것임.

```tsx

```tsx
  const handleClick = () => {
    axios.get<{ items : Repository[] }>(`https://api.github.com/search/repositories?q=${keyword}`)
    .then(response => setRepodata(response.data.items))
    .catch(error => console.log(error))
    }

  return (
    <div className="App">
      <input type="text" onChange={e => setKeyword(e.target.value)} value={keyword}/>
      <button onClick={handleClick}> ❤️Search❤️</button>
      <div className="ag-theme-material"
        style={{height: 500, width: 850}}
        >
        <AgGridReact 
        rowData={repodata}
        columnDefs={columnDefs}
        pagination={true}
        paginationPageSize={5}
        />
          
        </div>
      </div>
  )
}


export default App
```

이상에서 컬럼의 정의 및 거기에 딸려있는 properties를 확인했음. sortable / filter 였고, 그 다음에 추가적인 컬럼을 정의했는데, 거기에 cellRenderer라는 속성이었음.

그리고 pagenation / pagenationPageSize는 `<AgGridReact>` 컴포넌트 내부에 정의했었음.
return 문과 colDefs 상태를 둘 다 잘 확인하시기 바람.

cellRenderer 프롭을 이용하면 테이블 셀의 컨텐츠를 사용자 정의할 수 있음. 이상의 예시에서는 Ag Grid 내의 컬럼에서 버튼을 렌더링하는 예시였음.

cellRenderer 속성의 value는 callback 함수로 이루어져있음. 그리고 매개변수로 params를 받았고, ICellRenderParams Type으로 작성했고, params.value의 값은 field 속성에 정의된 full_name을 썼음. 그래서 버튼 누르면 full_name이 출력되었었음.

근데 보니까 컬럼 이름이 너무 대놓고 field와 동일하게만 되어있음. 그러다보니까 column 명을 확인해보면 Id / Full_name / Html_url / Full_name으로 Full_name 컬럼이 두 개인 것을 확인할 수 있음. 이를 수정하기 위해서는 `headerName` 속성을 활용할 수 있음.

# Material UI Component 이용
shoppinglist 프로젝트를 생성하시오.
React - TypeScript 쓸겁니다.
App.tsx 전부 초기화
npm install @mui/material@5.14.8
npm install @emotion/react@11.11.1
npm install @emotion/styled@11.11.0

```tsx
import { Container } from '@mui/material'
import {AppBar, Toolbar, Typography} from '@mui/material'
import './App.css'

function App() {


  return (
    <Container>
      <AppBar position="static">
        <Toolbar>
          <Typography variant='h6'>
            쇼핑 리스트 Shopping List
          </Typography>
        </Toolbar>
      </AppBar>
    </Container>
  )
}

export default App

```
이상에서 주의깊게 봐야 할 부분은 각 컴포넌트가 무슨 역할을 하는지 입니다.
Container는 전체 브라우저 화면을 의미하고, AppBar은 상단을 의미함. 그리고 ToolBar는 그 중에서도 nav와 비슷한 역할을 함.
Typography는 글씨 관련 영역을 나타냄

이하부터는 실제 shopping list의 기능과 관련된 부분을 작성할 예정.
당연히 MUI를 도입한 부분이 될것이기 때문에 일반적인 html + css+ js + react의 형태로는 어떻게 작성될 수 있을지 감안한 상태에서 코드를 확인해야 함.
```
```tsx
import { Button, TextField, Dialog, DialogActions, DialogContent, DIalogTitle } from "@mui/material"; 
import { useState } from "react";

function AddItem(props) {
  const [open, setOpen ] = useState(false);

  const handleOpen = () => {
    setOpen(true);
  }

  const handleClose = () => {
    setClose(false);
  }
  
  return(
    <>
    </>
  );
}
```
App 컴포넌트 내에 Additem 컴포넌트를 추가할것임. 그런데 저희 todolist 할 때는 input 창에 button 하나만 있었음. 그리고 gitpushapi 가지고 올 떄도 그랬음. 이번에는 Modal이라고 하는 개념을 추가할것임
근데 이 Modal을 저희가 처음 배우는건 아니고 1만시간의 법칙에서 했었음

폼에 product와 amount라는 두 개의 입력 필드와 App 컴포넌트 내에 addItem 함수를 호출하는 버튼을 추가할것임. _App 컴포넌트에 있는 addItem 함수를 호출할 수 있으려면 addItem 컴포넌트를 렌더링할 때 프롭으로 전달_ 해야함.
모달 Dialog 컴포넌트 외부에 사용자가 새 쇼핑항목을 입력할 수 있는 모달 폼을 여는 버튼을 주가해둘것임.
해당 버튼은 컴포넌트가 처음 렌더링 될 때 보이는 유일한 요소에 해당할 것임.
즉 최초에 open 상태가 false이기 때문에 모달 폼은 보이지 않고, 버튼만 보일것이라는 의미.

```tsx
import { Button, TextField, Dialog, DialogActions, DialogContent, DIalogTitle } from "@mui/material"; 
import { useState } from "react";

function AddItem(props) {
  const [open, setOpen ] = useState(false);
  const [item, setItem] = useState<Item>({
    product: '',
    amount: '',
});

  const handleOpen = () => {
    setOpen(true);
  }

  const handleClose = () => {
    setClose(false);
  }

  return(
    <>
    <Button onClick={handleOpen}>
      Add Item
    </Button>
    <Dialog open={open} onClose={handleClose}>
      <DialogTitle>New Item</DIalogTitle>
      <DialogContent>
          
        </DialogContent> 
        <Button onClick={handleClose}>
          Cancel / 취소
        </Button>
        <Button onClick={addItem}>
          Add / 저장
        </Button>
    </Dialog>
    </>
  );
}

export default Additem
```

이상에서 일단 주의해야할 점은 App.tsx에 정의되어있는 type인 Item을 가지고 왔다는 점임. 이 것은 프로젝트의 사이즈가 매우 작기 때문이고, 보통은 types.ts 파일에 전체 타입들이 정의되어있고, 거기서 가지고 오게 될것임.

그리고 addItem 함수가 App.tsx에 정의되어있지만, AddItem 컴포넌트에서 불러오고 있음. 이 부분에 대해서 의문을 가질 수 있음.
1. AddItem 컴포넌트 내에 addItem 함수를 정의하면 안되는가
 - App.tsx의 additem 함수를 확인하면 Item이 추가되고, 기존의 item들을 그대로 스프레드 연산자로 받아온다는 것을 확인할 수 있음
 - 여기서 중요한 점은 AddItem 컴포넌트에서 하나의 item을 추가한 것을 상위로 보낼 방법이 없다는 점임.
 - React 에서의 Data Flow는 상위->하위로 이어지는 Top-Down 방식이기 때문임. 즉 AddItem 컴포넌트에서 추가하는 함수를 별개로 만들어봤자 App 컴포넌트로 보낼 수 없기 때문에 결과적으로 App 컴포넌트에서 addItem 함수를 만들고, _해당 함수를 호출하는 함수를 AddItem 컴포넌트에 정의_ 해야한다고 생각할 수 있겠음.
 -React에서의 기초적인 원리 부분에서 One-way data flow에 대해 강조한 이유가 나오는 부분 중 하나임.
 -이게 너무 머리아프면 Recoil / ContextAPI 등의 전역 상태 관리를 통해서 함수를 전부 다 전역에 등록해서 불러오는 방법도 고려할 수 있음. 

```tsx
import { Button, TextField, Dialog, DialogActions, DialogContent, DialogTitle } from "@mui/material"; 
import { useState } from "react";

type AddItemProps = {
  addItem: (item: Item) => void;
}

function AddItem(props: AddItemProps) {
  const [open, setOpen ] = useState(false);
  const [item, setItem] = useState<Item>({
    product: '',
    amount: '',
});

  const handleOpen = () => {
    setOpen(true);
  }

  const handleClose = () => {
    setOpen(false);
  }

  // App.tsx의 addItem 함수를 호출하고, item 상태를 전달
  const addItem = () => {
    props.addItem(item);
    // TextField에 있는 내용을 다 지우고 Modal을 닫음 
    setItem({product: '', amount: ''}); 
  }

  return(
    <>
    <Button onClick={handleOpen}>
      Add Item
    </Button>
    <Dialog open={open} onClose={handleClose}>
      <DialogTitle>New Item</DialogTitle>
      <DialogContent>
          <TextField value={item.product} margin="dense"
          onChange={E => setItem({...item, product: E.target.value})}
          label="Product/제품명" fullWidth /> 
          <TextField value={item.amount} margin="dense"
            onChange={e => setItem({...item, amount: e.target.value})}
            label="Amount/수량" fullWidth          
          />
        </DialogContent> 
        <Button onClick={handleClose}>
          Cancel / 취소
        </Button>
        <Button onClick={addItem}>
          Add / 저장
        </Button>
    </Dialog>
    </>
  );
}

export default AddItem
```
 이상의 코드에서 props로 전달하는 함수 부분에 주목해야 합니다. 이를 위해 AddItemProps라는 type을 선언함.

 마찬가지로, App.tsx도 확인해야 함. 함수를 전달하기 위한 방식이었음.
 ```tsx
 import { Container } from '@mui/material'
import {AppBar, Toolbar, Typography} from '@mui/material'
import './App.css'
import { useState } from 'react'
import Additem from './AddItem'

export type Item = {
  product: string;
  amount: string;
}

function App() {
  const [ items, setiTems] = useState<Item[]>([]);
  const addItem = (item:Item) => {
    setiTems([item, ...items]);
  }


  return (
    <Container>
      <AppBar position="static">
        <Toolbar>
          <Typography variant='h6'>
            쇼핑 리스트 Shopping List
          </Typography>
        </Toolbar>
      </AppBar>
      <Additem addItem={addItem} />
    </Container>
  )
}

export default App
```

그렇다면 현재까지 작성한 것을 기준으로 했을 때 App.tsx에 있는 items 상태가 업데이트 된다는 것은 확인할 수 있음
근데 그 업데이트된 items를 보여주지 못하고 있네요.
그럼 업데이트된 items의 결과를 보여주는 return부분에서의 코드가 있어야 할 것 같습니다.

```tsx
import { Container } from '@mui/material'
import {AppBar, Toolbar, Typography} from '@mui/material'
import './App.css'
import { useState } from 'react'
import Additem from './AddItem'
import { List, ListItem, ListItemText } from '@mui/material'

export type Item = {
  product: string;
  amount: string;
}

function App() {
  const [ items, setiTems] = useState<Item[]>([]);
  const addItem = (item:Item) => {
    setiTems([item, ...items]);
  }


  return (
    <Container>
      <AppBar position="static">
        <Toolbar>
          <Typography variant='h6'>
            쇼핑 리스트 Shopping List
          </Typography>
        </Toolbar>
      </AppBar>
      <Additem addItem={addItem} />
      <List>
        {
          items.map((item, index) =>
            <ListItem key={index} divider>
              <ListItemText
              primary={item.product}
              secondary={item.amount}/>

            </ListItem>
          )
        }
      </List>
    </Container>
  )
}

export default App

```
이상에서 확인해야 하는 점은 기본적으로 items 상태를 업데이트 하는 부분이 어느 부분에 작성되어야 하는가입니다,
구조는 현재
App
 ↓
AppItem
컴포넌트 구조로 되어있습니다. 즉, App 컴포넌트에 items 결과값을 표시할 것이냐, AddItem 컴포넌트에 표시할 것이냐 1/2 확률이라고 볼 수 있겠네요.

심플하게 정리해봤을 때, imtes 상태가 정의된 곳이 어디죠?
App
그래서 App에 결과값 표시했습니다.

List 컴포넌트를 App 컴포넌트 내에서 랜더링했습니다. 지금 현재까지 MUI를 보시면 위계가 잡혀있다는 것을 알 수 있습니ㅏㄷ.
List -> ListItem -> ListItemText
ul -> ui
List 내에서 map() 함수를 활용하여 ListItem 컴포넌트를 생성했습니다.(ul 내부에서 map함수 써서 li를 만든 것과 동일함).
배열이기 때문에 key 프롭이 요구되는 것도 동일합니다.
그리고 `<ListItem key={index} divider>`에서 보시면 divider라는 속성이 있는데, 얘는 각 항목 끝부분에 구분선을 가지고 옵니다.
다음에 ListItemText에서 기본 텍스트로 product를 표시하고, 보조 텍스트로 amount를 표시했습니다. 각각 primary / secondary로 쓰였습니다. MUI에서 자주 쓰이는 속성입ㄴ디ㅏ.

또한 button의 스타일이 있는데, variant="outlined/text/contained"로 쓸 수 있습니다.

이상의 MUI 라이브러리를 사용하면 리액트 앱에서 일관되게 디자인을 하는 것이 가능합니다.
그리고 좋은 점은 프로젝트 찍어낼 때 CSS를 고려할 필요성이 덜하다는 점이죠.

하지만 기본값이 정해져있는만큼 커스터마이징을 하기 위해서는 emotion이나 tailwind를 고려할 필요도 있습니다.

밥 먹고 다음 시간에는 React Router를 활용하여 라우팅 관리를 하는 법을 수업하겠습니다.

# React Router
routerapp project를 생성  React / TypeScript
npm install
npm install react-router-dom@6
App.tsx
Home.tsx생성하고 초기화
Contact.tsx생성하고 초기화

React Router란 URL을 기반으로 특정 컴포넌트를 렌더링할지 정의할 수 있는 방식

react-router-dom 라이브러리는 라우팅을 구현하는 데 이용되는 컴포넌트들을 제공합니다.
1. BrowserRouter : 웹 기반 애플리케이션을 위한 라우터
2. Route : 주어진 위치가 일치하면 정의된 컴포넌트를 렌더링
이하는 Route 컴포넌트의 예시인데, element 속성은 사용자가 path 프롭에 정의된 contact 엔드포인트로 이동할 때 렌더링되는 컴포넌트를 정의합니다. 경로는 현재 위치를 기준으로 상대 경로를 작성합니다.
`<Route path="contact" element={<Contact />} />`
혹은 이하와 같이 path 속성 끝에 * 와일드카드를 이용하는 것도 가능합니다.
`<Route path="/contact/*" element={<Contact />} />`
그러면 contact/mike 혹은 contact/1 등의 엔드포인트들에 전부 다 Contact 컴포넌트가 렌더링됩니다.
또한, Route 컴포넌트는 여러 Route 컴포넌트를 감싸는 것이 가능합니다.
이를 위해서 Link 컴포넌트는 애플리케이션에 대한 탐색 기능을 제공하는데, 이하의 예시는 Contact 링크를 표시하며, 해당 링크를 클릭했을 때 `/contact` 엔드포인트로 이동합니다.
`<Link to="/contact">Contact</Link>`
```
```tsx
import { BrowserRouter, Routes, Route, Link } from 'react-router-dom'
import './App.css'
import Home from './Home'
import Contact from './Contact'
import PageNotFound from './PageNotFound'
import ContactSeoul from './ContactSeoul'
import ContactBusan from './ContactBusan'

function App() {


  return (
    <>
      <BrowserRouter>
      <nav>
        <Link to="/">Home</Link>{' | '}
        <Link to="/contact">Contact</Link>
      </nav>
      <Routes>
        <Route path="/" element={<Home />} />
        <Route path="contact" element={<Contact />}>
        <Route path="seoul" element={<ContactSeoul />} />
        <Route path="Busan" element={<ContactBusan />} />
        </Route>
        <Route path="*" element={<PageNotFound />} />
      </Routes>
      </BrowserRouter>
    </>
  )
}

export default App

```
```tsx
import { Link, Outlet } from "react-router-dom";


function Contact() {

  return (
    <>
      <h3>Contact Us ! ❤️</h3>
      <nav>
      <Link to="seoul">서울 지점</Link> {' | '}
      <Link to="busan">부산 지점</Link>
      </nav>
      <hr />
      <Outlet />
    </>
  );
}

export default Contact
```
`<Outlet />` : 중첩 라우트(Nested Routes)를 렌더링하기 위해 사용하는 일종의 자리 표시자(placeholder)입니다.

그러니까 Outlet 컴포넌트가 있는 장소에 해당 자식 컴포넌트를 불러내주세요, 라는 의미가 됩니다.
그러면 이상의 코드에서 보셨던 것처럼 App.tsx의 `<Route path="contact" element={<Contact />}>` 의 내부에 seoul과 busan 엔드포인트를 지정했고, 거기에 ContactSeoul과 ContactBusan을 이미 명시해뒀습니다. 그렇기 때문에 Contact 컴포넌트 내에서 다시 ContactSeoul 및 ContactBusan을 명시하는 것이 아니라 `<Outlet />` 컴포넌트를 통해서 불러온다고 생각하시면 됩니다.

이상의 라이브러리를 이용할 경우 컴포넌트들이 하나의 URL(예를 들어 localhost:5173)만 가지는 것이 아니라 각각의 다른 URL을 가지도록 통제하여 필요한 부분만을 렌더링할 수 있도록 합니다.

# 금일 현재까지의 학습 내용 요약
1. 3rd party 컴포넌트들을 학습했습니다.
 - react-date-picker는 그냥 설치하는 방법 보여드렸습니다.
 - AgGrid를 이용했습니다.
   - 테이블을 대체하는 컴포넌트
    - filter, sort, column 정의와 관련된 부분을 학습했습니다.
 - MUI 컴포넌트
  - 이상에서 중요한 것은 각각의 HTML 태그에 해당하는 컴포넌트들이 존재한다는 점입니다.
    - `<input>` 태그를 대체하는 것은 `<TextField>`인 등
    - 내부에 MUI 자체 property가 있기 때문에 학습 필요성이 있습니다.
    - 귀찮게 하나하나 학습할거면 왜 쓰냐 싶은데 이게 CSS보다 훨씬 쉬워서 그렇습니다.
  -react-router-dom
   -SPA 상에서의 하나의 URL이 아니라 다수의 URL을 다루는 방식을 학습했습니다.
   -조건부 렌더링이 if문이나 삼항연산자를 쓰는 것 뿐만 아니라, 내부의 URL을 기준으로 서로 다른 컴포넌트를 렌더링할 수 있도록 하는 방식이었습니다.

   외부 라이브러리를 다루는 현재 시점에서는 제 수업 자체보다는 공식문서의 활용이 매우 중요합니다. 여러분들이 프로젝트 때 어떤 라이브러리를 다루게 될 지 모르니까요.

# Full Stack 개발 - 스프링부트 RESTful API 웹 서비스를 위한 프론트엔드
## UI prototype
1. 데이터베이스의 자동차를 테이블에 나열하고, 페이징, sorting, filtering 기능을 구현할겁니다. - AG Grid를 써서
2. 데이터베이스에 새 차량을 추가할 수 있는 모달 폼을 여는 버튼을 구현할겁니다. - MUI를 사용해서
3. 차량 테이블의 각 행에 자동차를 편집하거나 데이터베이스에서 삭제하는 버튼을 구현할겁니다.
AG Grid에 있었는데, 거기에 버튼 클릭했을 때, 특정 함수가 호출되고, 그게 백엔드로 전달 -> DB로 들어가서 PUT 혹은 DELETE 메서드를 실행시킬겁니다. 
4. CSV 파일로 변경하여 내려받기가 가능한 링크 혹은 버튼을 구현해볼까 합니다.

## FrontEnd React 프로젝트 생성
carfront project를 생성 React / Typescript
npm install
npm install @emotion/react@11.14.0
npm install @emotion/styled@11.14.0
npm install @mui/material@5.17.1
npm install @tanstack/react-query@4.36.1
npm install axios@1.9.0
App.tsx를 전체 초기화
npm run dev
git add .
git commit -m "feat: carfront project creation"
git push



